module;

#include <cassert>
#include <coroutine>
#include <string>
#include <variant>
#include <vector>

export module miller.dialect.core;

import miller.coro;
import miller.util;
import miller.program;

export namespace mi::core {

    //
    // arithmetic expressions
    //

    struct constant {

        constexpr constant(mi::integral_like auto v)
            : value(v)
        {}

        bigint_t value;
    };

    struct variable {
        std::string name;
    };

    struct arithmetic_binary {
        enum class kind_t { add, sub, mul, div };

        kind_t kind;
        box< struct aexpr_t > lhs, rhs;
    };

    using aexpr_base = std::variant<
        constant, variable, arithmetic_binary
    >;

    struct aexpr_t : aexpr_base {
        using aexpr_base::aexpr_base;
    };

    //
    // boolean expressions
    //
    struct boolean_constant { bool value; };

    struct lnot {
        box< struct bexpr_t > expr;
    };

    struct logical {
        enum class kind_t { land, lor };

        kind_t kind;
        box< struct bexpr_t > lhs, rhs;
    };

    struct relational {
        enum class kind_t { lt, le, eq, ne, gt, ge };

        kind_t kind;
        box< aexpr_t > lhs, rhs;
    };

    using predicate = relational::kind_t;

    template< predicate pred >
    relational make_relational(aexpr_t &&lhs, aexpr_t &&rhs) {
        return relational{
            pred, std::forward< decltype(lhs) >(lhs), std::forward< decltype(rhs) >(rhs)
        };
    }

    using bexpr_base = std::variant<
        boolean_constant, logical, relational
    >;

    struct bexpr_t : bexpr_base {
        using bexpr_base::bexpr_base;
    };

    //
    // expressions
    //

    using expr_t = std::variant< aexpr_t, bexpr_t >;

    //
    // statements
    //

    struct assign : operation_base {
        variable var;
        expr_t expr;

        assign(variable v, expr_t e)
            : var(std::move(v))
            , expr(std::move(e))
        {}

        constexpr bool escape() const noexcept { return false; }
    };

    struct skip : operation_base {
        constexpr bool escape() const noexcept { return false; }
    };

    struct break_loop : operation_base {
        constexpr bool escape() const noexcept { return true; }
    };

    struct terminate : operation_base {
        constexpr bool escape() const noexcept { return false; }
    };

    constexpr auto skip_stmt  = skip();
    constexpr auto break_stmt = break_loop();
    constexpr auto terminate_stmt  = terminate();

    using stmt_t = std::variant<
        assign, skip, break_loop, terminate,
        box< struct conditional >,
        box< struct while_loop >
    >;

    constexpr bool escape(const stmt_t &stmt) noexcept;

    struct conditional : operation_base {
        bexpr_t cond;
        stmt_t then_stmt, else_stmt;

        conditional(bexpr_t c, stmt_t t, stmt_t e)
            : cond(std::move(c))
            , then_stmt(std::move(t))
            , else_stmt(std::move(e))
        {}

        constexpr bool escape() const noexcept {
            return mi::core::escape(then_stmt) || mi::core::escape(else_stmt);
        }
    };

    struct while_loop : operation_base {
        bexpr_t cond;
        stmt_t body;

        while_loop(bexpr_t c, stmt_t b)
            : cond(std::move(c))
            , body(std::move(b))
        {}

        constexpr bool escape() const noexcept { return mi::core::escape(body); }
    };

    constexpr bool escape(const stmt_t &stmt) noexcept {
        return std::visit(
            overloaded{
                [] (const boxed auto &b) { return b->escape(); },
                [] (const auto &s) { return s.escape(); }
            }, stmt);
    }

    struct compound : operation_base {
        std::vector< stmt_t > stmts;

        template< std::convertible_to< stmt_t > ...statements >
        compound(statements &&...s) {
            stmts.reserve(sizeof...(statements));
            (stmts.emplace_back(std::forward< statements >(s)), ...);
        }

        [[nodiscard]] auto front() const { return stmts.front(); }
        [[nodiscard]] constexpr bool empty() const noexcept { return stmts.empty(); }
    };

    struct program : operation_base {
        compound body;

        template< std::convertible_to< stmt_t > ...statements >
        program(statements &&...s)
            : body(std::forward< statements >(s)...)
        {}

        [[nodiscard]] auto front() const { return body.front(); }
        [[nodiscard]] constexpr bool empty() const noexcept { return body.empty(); }

        constexpr label entry() const noexcept { return body.entry(); }
        constexpr label exit()  const noexcept { return body.exit(); }
        constexpr bool escape() const noexcept { return body.escape(); }

        constexpr label breaks_to() const noexcept { return body.breaks_to(); }

        coro::recursive_generator< label > breaks_of() const noexcept { co_yield body.breaks_of(); }
        coro::recursive_generator< label > internal_labels() const noexcept { co_yield body.internal_labels(); }
        coro::recursive_generator< label > labels() const noexcept { co_yield body.labels(); }
        coro::recursive_generator< label > reachable_labels() const noexcept { co_yield body.reachable_labels(); }
    };

} // namespace mi::core
