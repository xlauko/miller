module;

#include <concepts>
#include <coroutine>

#include <refl.hpp>
#include <spdlog/spdlog.h>

export module miller.program:operation;

export import :label;

import miller.coro;
import miller.util;

export namespace mi {

    template< typename range, typename value >
    concept range_of =
        std::ranges::range< range > &&
        std::convertible_to< std::ranges::range_value_t< range >, value >;

    template< typename range >
    concept labels_range = range_of< range, label >;

    template< typename type >
    concept operation = requires(type op) {
        // The program point at which execution of operation starts
        { op.entry() }  -> std::convertible_to< label >;

        // The program exit point after operation, at which execution of it is
        // supposed to normally terminate, if ever
        { op.exit() }   -> std::convertible_to< label >;

        // A Boolean indicating whether or not the operation contains a break
        // statement
        { op.escape() } -> std::convertible_to< bool >;

        // The program point to which execution of the operation goes when a
        // break statement escapes out of the operation
        { op.breaks_to() }        -> std::convertible_to< label >;

        // The set of labels of all break statements inside operation that can
        // escape out of the operation
        { op.breaks_of() }        -> labels_range;

        // The set of program points inside operation (including entry labels
        // but exluding exit and breaks_to labels)
        { op.internal_labels() }  -> labels_range;

        // The potentially reachable program points while executing operation
        // either in or after the operation (exluding reachability by a break)
        { op.labels() }           -> labels_range;

        // The potentially reachable program points while executing operation.
        // Includes entry, internal, and exit labels, or labels resulting from
        // break.
        { op.reachable_labels() } -> labels_range;
    };

    struct scope_base {};

    template< typename derived >
    struct [[nodiscard]] operation_base {
        operation_base() = default;

        operation_base(operation_base &&) = default;
        operation_base(const operation_base &) = delete;

        operation_base& operator=(operation_base &) = default;
        operation_base& operator=(const operation_base &) = delete;

        const derived& self() const noexcept { return *static_cast< const derived* >(this); }
        derived& self() noexcept { return *static_cast< derived* >(this); }

        constexpr bool has_internal_scope() const noexcept {
            return has_member_derived_from< derived, scope_base >();
        }

        static constexpr bool is_scope = std::is_base_of_v< scope_base, derived >;

        label this_label() const noexcept { return self_entry_label(*this); }

        constexpr label entry() const noexcept { return this_label(); }
        constexpr label exit()  const noexcept { return next_label_tag; }

        constexpr bool escape() const noexcept { return false; }

        constexpr label breaks_to() const noexcept { return {}; }

        coro::recursive_generator< label > breaks_of() const noexcept { co_yield label{}; }
        coro::recursive_generator< label > internal_labels() const noexcept { co_yield label{}; }
        coro::recursive_generator< label > labels() const noexcept { co_yield label{}; }
        coro::recursive_generator< label > reachable_labels() const noexcept { co_yield label{}; }
    };

} // namespace mi

REFL_AUTO( type(mi::scope_base) )
